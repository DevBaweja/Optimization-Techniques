%%  Requirement For Simplex Method
% max objective function 
% <= constraint
% b is positive

%% Function begin
% f is coefficient of objective function (row vector)1xn
% A is coefficient of constraint (matrix)mxn
% b is right hand side of constraint (column vector)mx1

% where n is number of variable
% where m is total number of constraint

function z = simplex(f,A,b)
[m,n] = size(A);
[~,ncheck] = size(f);
[mcheck,~] = size(b);
format compact
% checking for dimension
    if n==ncheck && m==mcheck
        cj = [f,zeros(1,m)]; % row vector
        xb = b; % column vector
        cb = zeros(1,m)'; % column vector
        
        % making basic matrix inside
        slack = eye(m);
        x = [A,slack]; % matrix
        deltaj = zeros(1,(m+n));
        basic = (n+1:n+m)'; % initial values
        
        while true
           
            % Values is assigned
            for i=1:(n+m)
                eval(['x' num2str(i) ' = x(:,i);']);
                eval(['x' num2str(i) ';']);
            end 
            
            % fprintf("xmain \n");
            % disp(x);
            tx = array2table(x);
            t = table(cb,xb);
            tnew = horzcat(t,tx);
            tnew.Properties.RowNames = string(basic);

            disp(tnew);
        % calculating deltaj 
            for i = 1:(n+m) 
                deltaj(i) = sum(cb.*x(:,i))-cj(i); 
            end
            fprintf("Deltaj \n");
            disp(deltaj);
            
            if min(deltaj)<0 
                 % getting incoming vector
                [~,incoming] = min(deltaj);
                fprintf("Incoming = %s \n",[ 'x' num2str(incoming)]); 
                
                xi = x(:,incoming);
                % calculating minratio
               minratio = zeros(m,1);
               for i = 1:m
                   if xi(i)>0
                      minratio(i) = xb(i)/xi(i); 
                   else
                        minratio(i) = NaN;  
                   end
               end
               fprintf("Minratio \n");
               disp(minratio);
               if isnan(minratio) 
                   fprintf("Unbounded Solution & Unbounded Region \n");
                   return;
               else
                     % getting outgoing vector
                   [~,outgoing] = nanmin(minratio);
                   fprintf("Outgoing = %s \n", ['x' num2str(basic(outgoing))] );
                   
                   pivot = x(outgoing,incoming);
                   fprintf("Pivot = %d \n",pivot);
                   
                   % Matrix operation
                   x(outgoing,:) = x(outgoing,:)/pivot;
                   xb(outgoing) = xb(outgoing)/pivot;
                   % Making remaining pivot column zero
                   for i = 1:m
                       if i~=outgoing % excluding pivot row
                           tx = x(i,incoming);
                           x(i,:) = x(i,:) - tx*x(outgoing,:);
                           xb(i) = xb(i) - tx*xb(outgoing);
                       end
                   end
                   % Making change in cb and basic variables
                   cb(outgoing) = cj(incoming);
                   basic(outgoing) = incoming;
               end
               
            else
                % reached at optimal solution
                fprintf("Optimal Solution is achieved \n");
                fprintf("Basic Variables \n");
                disp("x"+basic);
                % Finding solution
                X = zeros(1,n+m);
                nonbasic = true(1,n+m);
                for i = 1:m
                    X(basic(i)) = xb(i);
                    nonbasic(basic(i)) = false;
                end
                % For unbounded region
                for i=1:(n+m)
                   if x(:,i)<=0 % only true when all the element are 0 or -ve along any column
                       fprintf("Unbounded region along x%d \n",i);
                   end
                end
                
                fprintf("X : ");
                disp(X);
                
                % For infinite solution 
                for j=1:(n+m)
                    if nonbasic(j) && deltaj(j) == 0
                        fprintf("Infinite Solution indicates by x%d \n",j);
                        fprintf("Incoming = %s \n",[ 'x' num2str(j)]);
                        incoming = j;
                            xi = x(:,incoming);
                            % Constructing next table for point
                            % calculating minratio
                           minratio = zeros(m,1);
                           for i = 1:m
                               if xi(i)>0
                                  minratio(i) = xb(i)/xi(i); 
                               else
                                    minratio(i) = NaN;  
                               end
                           end
                           fprintf("Minratio \n");
                           disp(minratio);
                           if isnan(minratio) 
                               fprintf("Infinite Case \n");
                               fprintf("X:\n");
                               disp(X);
                               Xnew = X;
                               for i=1:m
                                   Xnew(basic(i)) = X(basic(i))-xi(i);
                               end
                               for i=1:(n+m)
                                   if Xnew(i)-X(i) == 0
                                       fprintf("%d\t",X(i));
                                   else
                                       fprintf("%d+%dq\t",X(i),Xnew(i)-X(i));
                                   end
                               end
                               fprintf("")
                           else
                                 % getting outgoing vector
                               [~,outgoing] = nanmin(minratio);
                               fprintf("Outgoing = %s \n", ['x' num2str(basic(outgoing))] );
                               
                               pivot = x(outgoing,incoming);
                               fprintf("Pivot = %d \n",pivot);
                               
                               % Matrix operation
                               x(outgoing,:) = x(outgoing,:)/pivot;
                               xb(outgoing) = xb(outgoing)/pivot;
                               % Making remaining pivot column zero
                               for i = 1:m
                                   if i~=outgoing % excluding pivot row
                                       tx = x(i,incoming);
                                       x(i,:) = x(i,:) - tx*x(outgoing,:);
                                       xb(i) = xb(i) - tx*xb(outgoing);
                                   end
                               end
                               % Making change in cb and basic variables
                               cb(outgoing) = cj(incoming);
                               basic(outgoing) = incoming;
                               
                                tx = array2table(x);
                                t = table(cb,xb);
                                tnew = horzcat(t,tx);
                                tnew.Properties.RowNames = string(basic);
                                disp(tnew);
                                
                                Xnew = zeros(1,n+m);
                                for i = 1:m
                                    Xnew(basic(i)) = xb(i);
                                end
                                fprintf("X:\n");
                                disp(X);
                                fprintf("Xnew:\n");
                                disp(Xnew);
                                fprintf("Convex Combination forming with these points \n");
                                printconvex(X,true);
                                fprintf("+");
                                printconvex(Xnew,false);
                           end
                   end
                end
                % disp(nonbasic);
                fprintf("z : %d \n",sum(cb.*xb));
                return;
            end
%             
        end
    else
        fprintf("Dimension Mismatch Error");
    end
end

function printconvex(X,b)
    [~,loop]=size(X);
    if b
        fprintf("q(");
    else
        fprintf("(1-q)(");
    end
        for i=1:loop
            if i==loop
                fprintf("%d",X(loop));
            else
             fprintf("%d,",X(i));
            end
        end
    fprintf(")");
    if ~b
        fprintf("\t where 0 <= q <= 1 \n");
    end
end